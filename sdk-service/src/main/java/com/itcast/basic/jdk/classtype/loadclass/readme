对jvm的思考:

字节码获取方式:className.class Class.forName() instance.getClass()

new Instance()执行过程:
jvm实例化对象时首先递归初始化该实例对应类的父类即初始化父类的静态代码(静态代码块和静态域 初始化顺序按照代码中出现顺序)
若实例对应类的父类均被初始化完毕 则执行子类实例的初始化即初始化子类静态代码(静态代码块和静态域 初始化顺序按照代码中出现顺序)
然后递归初始化父类实例代码(代码块和实例域初始化)初始化完毕后调用自身的构造方法
最后初始化自己的实例代码(代码块和实力域)初始化完毕后调用自身构造方法

jvm内存模型
               .java源文件
                   ||
                   ||编译器
                   \/
                .class文件
                   ||
                   ||
                   \/
      -------------------------------------------                         -------------------------------------------------
     |                                          |                        |    程序计数器          栈      本地方法栈       |
     |     classloader<-------执行引擎          |                        |                                                 |
     |        |                   |             |                        |                                                 |
     |        |                   |             |    运行时数据区        |                      堆                         |
     |       -----------------------            |------------------>     |    方法区                                       |
     |       | 运行时数据区         |           |                        |                                                 |
     |       |                      |           |                        |                                                 |
     |       ------------------------           |                        ----------------------------------------------------
     |                                          |
     --------------------------------------------

(1)程序计数器:记录当前CPU即将执行的下一条指令的地址
(2)方法区(永久代):存放字节码(类信息 静态变量等) 字符串常量池
(3)栈(线程栈):局部变量表、方法返回地址、运行时指向方法区的引用、附加信息
(4)堆:存放数组和对象

对jvm程序运行机制的思考:
java程序执行过程包括加载 连接(验证 准备 解析) 初始化 使用 卸载
(1)加载
jvm通过Class.forName()全类名的方式将.class字节码加载到内存,然后将字节码转换为运行时方法区数据结构,最后在堆中创建java.lang.Class对象
(2)连接
 * (1)验证
 *    首先验证二进制文件格式(保证输入的字节流能正确地解析并存储)
 *    其次验证元数据(对类的元数据信息进行语义校验)
 *    然后验证字节码(数据流和控制流的验证)
 *    最后验证符号引用
 * (2)准备
 *    为类变量和常量申请内存空间并赋系统默认值
 * (3)解析
 *   虚拟机将常量池内的符号引用替换为直接引用的过程(类和接口的解析 字段解析 类方法解析 接口方法解析 )
 (3)初始化
  * (1)<clinit>方法是由虚拟机自动收集类中静态变量的赋值语句和静态代码块中的语句合并而产生,虚拟机收集的顺序取决于代码在源文件中出现的顺序
  * (2)<clinit>方法和类的构造函数不同,它不需要显式的被调用,虚拟机会保证父类的<clinit>总是在子类的<clinit>方法调用前被调用.因此虚拟机中
  *    第一个执行<clinit>方法的类一定是java.lang.Object
  * (3)由于父类的<clinit>函数优先于子类的<clinit>执行,所以父类的静态变量赋值和静态代码块由于子类的静态变量赋值和静态代码块的执行
  * (4)<clinit>方法对于类和接口不是必须的,如果一个类或接口中没有静态变量赋值语句和静态代码块则编译器不会为其生成<clinit>方法
  * (5)接口的实现类初始化话时不会调用接口的<clinit>方法(笔者在探索中..)
  * (6)虚拟机会保证一个类的<clinit>方法在多线程执行环境中保证正确的加锁和同步

 * 标记删除法:标记删除法分为标记阶段和删除阶段 标记阶段主要是标记jvm中可以回收的对象 删除阶段主要是释放标记阶段标记的对象 缺点:会造成大量内存碎片
 * 标记整理法:标记整理法首先将存活对象移动到内存中的一端 当需要垃圾回收时 直接释放端外边缘的内存
 * 复制法:将内存分为2块 一块用来保存对象 一块空闲 当需要垃圾回收时 首先将存活的对象复制到空闲块中 然后直接释放保存对象块的内存 缺点:内存利用率不高
 * 分代法:分代法根据对象存活的周期将内存分为新生代和老年代 新生代存放存活周期短的对象 老年代存放存活周期长的对象
 * java jvm垃圾回收机制和过程:
 * 当创建一个新对象时 jvm会首先检查新生代(Eden+Survivor(from space+to space))的Eden中是否有足够空间存放新对象 如果有则将新对象存放到Eden区
 * 否则触发垃圾回收(首先标记Eden和from space中存活的对象然后逐个复制到to space中,当to space中的内存不能存放某个对象时则将该对象直接存到老年代
 * 然后释放Eden和from space的内存)




对jvm垃圾回收机制的思考:
jvm垃圾回收仅限于堆内存的回收 jvm使用根搜索算法判断堆中对象是否存活
(1)标记清除算法
jvm首先标记待回收对象 然后在gc时直接清空被标记对象占用内存 造成大量内存碎片
(2)标记整理算法
jvm首先将待回收对象移到内存空间的一端(连续的内存空间) 然后在gc时直接清空整理好的内存
(3)复制算法
jvm首先将内存空间均分为2份 将存活对象移到其中一份 然后在gc时直接清空另一份内存
(4)分代算法
jvm根据对象存活周期将其分为新生代和老年代

分代算法执行过程:
当new object时 jvm首先会检查新生代(Eden +Survivor(from space + to space))空间 若空间充足则将对象存入新生代
否则 jvm触发垃圾回收机制 jvm标记Eden区和from space区存活的对象 然后逐个复制到to space 若空间充足 则复制后清空 Eden区和from space区 然后将对象存入Eden区
否则直接将对象存入老年代 然后清空Eden区和from space区


对jvm垃圾收集器的思考:
(1)serial(串行收集器):
(2)parNew:
(3)parallel Scavenge
(1)(2)(3)新生代收集器
(4)CMS:
(5)serial old
(6)parallel old
(4)(5)(6)老年代收集器
(7)G1:新生代+老年代

jvm常用操作命令:
jps:主要用来输出JVM中运行的进程状态信息
jstat:JVM统计监测工具
jstack:主要用来查看某个Java进程内的线程堆栈信息
jmap:用来查看堆内存使用状况


jvm常用配置介绍:
Trace跟踪参数

 -verbose:gc

 -XX:+printGC

 -XX:+PrintGCDetails

 -XX:+PrintGCTimeStamps

 -Xloggc:log/gc.log // 指定GC log的位置，以文件输出

 -XX:PrintHeapAtGC // 每一次GC后，都打印堆信息

// 类加载信息

-XX:TraceClassLoading

-XX:+PrintClassHistogram

 -Ctrl +Break  打印类信息， 类的使用情况


-XX: +HeapDumpOnOutOfMemoryError

     - OOM时导出堆到文件

-XX:+HeapDumpPath

     - 导出OOM的路径

     栈大小分配

     -Xss

-Xmn

 -设置新生代大小

 -XX：NewRatio

 - 新生代（eden +2*s） 和老年代（不含永久区）的比值

 -4 表示新生代：老年代=1：4 ，即年轻代占堆的1/5

-XX：SurvivorRatio

 - 设置两个SurvivorRatio  区和eden 的比

 -8 表示 两个Survivor:eden =2:8,即一个Survivor 占年轻代的1/10

 -Xmx  -Xms

  - 指定最大堆 和最大堆

  -XX:PermSize -XX:MaxPermSize

  - 设置永久区的初始空间和最大空间














