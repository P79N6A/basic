#elasticsearch(1.7.1) 
#查询集群是否健康
GET /_cluster/health
#关闭集群
GET /_cluster/nodes/_shutdown
#获得集群中的节点信息
GET /_cluster/state/nodes
#在elasticsearch.yml文件设置索引是否自动创建
#action.auto_create_index:false
#设置索引分片和副本信息
PUT shop
{
  "settings": {
    "number_of_shards": 5,
    "number_of_replicas": 1
  }
}
#自定义日期格式
PUT shop
{
  "mappings": {
     "cloth":{
       "dynamic_date_formats": ["yyyy-MM-dd hh:mm"]
     }
  }
}
#开启文本检测
PUT shop
{
  "mappings": {
     "cloth":{
       "numeric_detection": true
     }
  }
}
#核心字段
#string字符串
#number数字
#date日期
#boolean布尔型
#binary二进制
#公共属性
#index_name该属性定义将存储在索引中字段的名字
#index可以设置为no和analyzed（如果是string类型可以设置为#not_analyzed）如果设置为no将无法搜索该字段，如果设置为
#analyzed,该字段将被编入索引以供搜索，（在基于字符串的字#段中可以设置为not_analyzed意味着字段不经分析而被编入索引#,搜索时必须完全匹配）
#store这个属性可以设置为no或者yes,指定该字段的原始值是否#被写入索引（使用_source则忽略该设置）
#boost改属性表示字段在文档中的重要性，值越大重要性越高
#copy_to此属性制定一个字段，字段的所有值都将复制到指定字段
#analyer该属性定义用于索引和搜索的分析器名字，默认全局定义的分#析器的名字
#index_analyer该属性定义了用于建立索引的分析器的名字
#search_analyer该属性定义用于搜索的分析器名字
#index_options该属性定义信息列表的索引选项
#数值类型
#byte定义字节
#short定义整短型值
#integer定义整型值
#long定义长整型值
#float定义浮点值
#double定义双精度值
#form属性指定日期格式
#precision_step指定在改字段中的每个值生产的词条数，值越小产生#的词条数越高
#多字段（有时可以把几个核心类型映射到单个字段）
#
#"name":
#{
#  "type":"string",
#  "fields":{
#      "field1"：{
#        "type":"string","index":"not_analyzed"
#      },
#      "field2"：{
#        "type":"string","index":"not_analyzed"
#      }
#    }
#  }
#
PUT blogs/blog/1
{
  "name":"This is a blog",
  "descript":"this is  a test application"
}
GET blogs/blog/2
#索引批量处理(换行符为标识符)
POST /_bulk
{"delete":{"_index":"blogs","_type":"blog","_id":"1"}}
{"index":{"_index":"blogs","_type":"blog","_id":"2"}}  
{ "name":"This is a blog","descript":"this is  a test application"}
{ "update": { "_index": "blogs", "_type": "blog", "_id": "2"} }
{ "doc" : {"name" : "My updated blog post"} }
{ "create": { "_index": "blogs", "_type": "blog", "_id": "4" }}
{ "name":    "My second blog post" }
#索引的其他设置选项
PUT book
{
  "mappings": {
    "book":{
      "properties":
      { 
        
      },
      "_all":{
          "enabled":false
        },
        "_source":{
          "enabled":false
        },
        "_index":{
          "enabled":true
        },
        "_size":{
          "enabled":true,
          "store":true
        },
        "_timestamp":{
          "enabled":true,
          "format": "YYYY"
        },
        "_ttl":{
          "enabled":true,
          "default":"30d"
        }
    }
  }
}
#创建索引
PUT /blog/article/1 
{
  "title":"elasticsearch",
  "content":"version 1.0",
  "tags":["version","elasticsearch"]
}
#查询字段
GET /blog/article/1/_source
#查询map
GET /blog/article/_mapping
#更新索引字段
POST /blog/article/1/_update
{
  "script": "ctx._source.content=\"new content\""
}
#添加一个新字段
POST /blog/article/1/_update  
{
   "script" : "ctx._source.views=12"  
}
#删除指定索引的全部信息
DELETE blog
#删除索引
DELETE /blog/article/1

#创建三个索引
PUT /books/es/1
{
  "title":"elasticsearch server",
  "published":"2013"
}
PUT /books/es/2
{
  "title":"mastering elasticsearch",
  "published":"2013"
}
PUT /books/solr/1
{
  "title":"apache solr 4 cookbook",
  "published":"2012"
}
#简单查询语句
GET /books/_search
{
  "query": {
    "match": {
      "title": "solr"
    }
  }
}
DELETE posts 
POST /posts 
{ 
  "settings":{
    "number_of_replicas":"1",
    "number_of_shards":"2"
  },
  "mappings":{
    "post":{
      "dynamic":"false",
      "properties":{
        "id":{"type":"long","store":"yes","precision_step":"1"},
        "name":{"type":"string","store":"yes","index":"analyzed"},
        "published":{"type":"date","store":"yes","precision_step":"1"},
        "content":{"type":"string","store":"no","index":"not_analyzed"},
        "address_count":{"type":"token_count","store":"yes","analyzer":"ik"}
      }
    }
  }
} 
GET posts
GET /posts/post/1
POST /posts/post/3
{  
  "id":23,
  "name":"hstyle",
  "published":"1991-12-16",
  "content":"this is hstyle",
  "address_count":5
}
GET /posts/post/_search
{
  "query": {
    "match": {
      "content": "this is hstyle"
    }
  }
} 
#分析器和过滤器的使用
PUT /resumes 
{
  "settings": {
    "index":{
      "analysis":{
        "analyzer":{
          "en":{
            "tokenizer":"standard",
            "filter":[ 
                "asciifolding",
                "lowercase",
                "myfilter"
              ]
          }
        },
        "filter":{
          "myfilter":{
            "type":"kstem"
          }
        }
      }
    },
    "mappings":{
      "resume":{
        "properties":{
          "id":{
            "type":"long","store":"yes"
          },
          "name":{
            "type":"string","store":"yes","index":"analyzed","analyzer":"en"
          }
        }
      }
    }
  }
}
#查看切词器切词结果
GET /resumes/_analyze?pretty&analyzer=en&text=robots cars
#elasticsearch批量操作(操作指令+操作json数据)
POST /resumes/resume/1/_bulk
    {"index":{"_index":"addr","_type":"contact","_id":"1"}}
    {"name":"tom","sex":"man"} 
    {"create":{"_index":"addr","_type":"contact","_id":"1"}}
    {"name":"tom","sex":"man"} 
    {"delete":{"_index":"addr","_type":"contact","_id":"1"}}
#常用标识符
#_id _type _all _source
#指定_id的值用resume_id代替
#是否启用_all字段 默认启用
#指定_source字段是否排除或包含某字段
PUT /resumes
{
   "resume":{
     "_id":{
       "path":"resume_id" 
     },
     "_all":{
       "enabled":"false"
     },
     "_source":{
       "excludes":["author*"],
       "includes":["resume*"]
     },
     "_index":{
       "enabled":"false"
     }
   }
}
#简单的查询 fields指定结果中显示的字段(字段的store设置为true)
#部分字段
#使用脚本动态添加计算字段
#脚本传入参数
GET /products/product/_search
{
  "from": 0, 
  "size": 5, 
  "version": true, 
  "fields": ["title","name","color.name"],  
  "partial_fields": {
    "name": {
      "include": ["女*"],
      "exclude": ["*新品"]
    }
  }, 
  "script_fields": {
    "new_sales": {
      "script": "10*doc['stock']-3-param_sales", 
	  "params": {
        "param_sales":2
      }
    }
  }, 
  "query": {
    "query_string": {
      "default_field": "title",
      "query": "name:韩都衣舍"
    }
  }
}
GET /products/product/_search
{
  "from": 0, 
  "size": 5, 
  "version": true, 
  "fields": ["title","name","color.name"],  
  "partial_fields": {
    "name": {
      "include": ["女*"],
      "exclude": ["*新品"]
    }
  }, 
  "script_fields": {
    "new_sales": {
      "script": "_source.stock-3"
    }
  }, 
  "query": {
    "query_string": {
      "default_field": "title",
      "query": "name:韩都衣舍"
    }
  }
}
#多词条查询
#minimum_match 表示匹配词条个数
#name是被词条匹配的字段
GET products/_search
{
  "query": { 
      "terms": 
      {
        "name":["韩都","amh"],
        "minimum_match": 1
      } 
  }
}
#常用词查询
#cutoff_frequency用于构建高低频词组
#当词频率<cutoff_frequency的词会出现在低频词组
GET products/_search
{
  "query": {
    "common":{
      "name":{
        "query":"amh 男士",
        "cutoff_frequency":0.001
      }
    }
  }
}
#match
GET products/_search
{
  "query": {
    "match": {
      "name": {
        "query": "amh 男装",
        "operator": "and"
      }
    }
  }
}
#match_phrase类似布尔查询（从分析后的结果构建短语查询）
#slop定义未知词条数
GET products/_search
{
  "query": {
    "match_phrase": {
      "name": {
        "query": "amh 男装",
        "slop":1
      }
    }
  }
}

#模糊查询
#max_expansions指定模糊匹配词条的省略词数
GET products/_search
{
  "query": {
    "match_phrase_prefix": {
      "name":{
        "query": "amh 男",
        "slop":1,
        "max_expansions": 20
      }
    }
  }
}
#多词条查询
GET products/_search
{
  "query": {
    "multi_match": {
      "query": "amh 男装",
      "fields": ["name","brand.name"]
    }
  }
}
#字符串查询
GET products/_search
{
  "query": {
    "query_string": {
      "default_field": "name",
      "query": "name:amh^6 +product_parent_category:男装 -name:hstyle",
      "use_dis_max": true
    }
  }
}
#标识符查询
GET products/_search
{
  "query": {
    "ids": {
      "type": "product", 
      "values": ["2","3"]
    }
  }
}
#simple_query_string查询
GET products/_search
{
  "query": {
    "simple_query_string": {
      "query": "amh",
      "fields": ["name"]
    }
  }
}
#前缀查询
GET products/_search
{
  "query": {
    "prefix": { 
        "name": "amh" 
    }
  }
}
GET products/_search
{
  "query": {
    "prefix": { 
        "name": {
          "value": "amh",
          "boost": 1
        } 
    }
  }
}

#分组统计（切面）
GET products/_search
{
  "query": {
    "match_all": {}
  }, 
  "facets": {
     "category.name.term":{
       "terms": {
         "field": "category.name.term" 
       }
     },
     "brand.id":{
       "terms": {
         "field": "brand.id" 
       }
     }
  }
} 
#多字段模糊查询
 GET products/_search
 {
   "query": {
     "fuzzy_like_this": {
       "fields": ["name","keywords"],
       "like_text": "18"
     }
   }
 }
#单字段模糊查询
GET products/_search
{
  "query":{
    "fuzzy_like_this_field": {
      "name":{
        "like_text":"amh"
      }
    }
  }
}
#fuzzy查询（防止拼写错误）
#min_similarity 最小相似度
GET products/_search
{
  "query": {
    "fuzzy": {
      "name":
      {
        "value":"armh",
        "min_similarity": 0.5
      }
    }
  }
}
#通配符查询(?表示任意字符 *表示)
GET products/_search
{
  "query": {
    "wildcard": {
      "name": {
        "value": "a*h"
      }
    }
  }
}
#more_like_this查询
#max_query_terms指定查询中能包括的最大查询词条数量（值越大精度越高性能越低）
#min_term_freq定义文档中最低词频
#min_doc_freq定义词条出现的文档数
GET products/_search
{
  "query": {
    "more_like_this": {
      "fields": [
        "name","plain_content"
      ],
      "like_text": "韩版",
      "min_term_freq": 1,
      "max_query_terms": 12 ,
      "min_doc_freq": 5
    }
  }
}
#more_like_this_field查询（more_like_this查询的单字段）
GET products/_search
{
  "query": {
    "more_like_this_field": {
      "name": {
        "like_text": "韩版",
        "min_term_freq": 1,
        "max_query_terms": 12,
         "min_doc_freq": 5
      }
    }
  }
}
#范围查询
GET products/_search
{
  "query": {
    "range": {
      "sales": {
        "gte": 10,
        "lte": 20
      }
    }
  }
}
#最大分查询
#(文档的最后得分：最高分数的子查询的得分之和
#，加上其余子查询的得分之和乘以tie的值)
GET  products/_search
{
  "query": {
    "dis_max": {
      "tie_breaker": 0.7,
      "boost": 1.2,
      "queries": [
        {
          "match": {
            "plain_content": "韩版"
          }
        },
        {
          "match": {
            "name": "amh"
          }
        }
      ]
    }
  }
}
#正则表达式
GET products/_search
{
  "query": {
    "regexp":{
      "name":{
        "value":"[0-9]{0,6}",
        "boost":10.0
      }
    }
  }
}
#布尔查询
GET products/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "name": {
              "value": "amh"
            }
          }
        }
      ],
      "should": [
        {
          "range": {
            "stock": {
              "from": 1,
              "to": 100
            }
          }
        }
      ],
      "must_not": [
        {
          "term": {
            "title": {
              "value": "null"
            }
          }
        }
      ]
    }
  }
} 
#加权查询
#positive包含返回文档得分不会被改变的查询
#negative包含返回文档得分被降低
#negative_boost用来降低negative包含文档的得分值
GET  products/_search
{
  "query": {
    "boosting": {
      "positive": {
        "match": {
          "name": "amh"
        }
      },
      "negative": {
        "range": {
          "stock": {
            "gte": 1,
            "lte": 20
          }
        }
      },
      "negative_boost": 0.2
    }
  }
}
#constant_score返回指定得分值的文档
GET products/_search
{
  "query": {
    "constant_score": {
      "query": {
        "match": {
          "name": "amh"
        }
      },
      "boost": 1.2
    }
  }
}
#索引查询
#当集群中存在多个索引时,query查询将执行在products索引上
#no_match_query查询将执行在集群中的其他索引上
GET products/_search
{
  "query": {
    "indices": {
      "indices": [
        "products"  
      ],
      "query": {
        "match": {
          "name": "amh"
        }
      },
      "no_match_query": {
        "match": {
          "name": "hstyle"
        }
      }
    }
  }
}
#post_filter过滤器(使用过滤器查询更高效也有缓存)
GET products/_search
{
  "query": {
    "match": {
      "name": "amh"
    }
  },
  "post_filter": {
    "term": {
      "stock": "426"
    }
  }
}
#filter过滤器
GET products/_search
{
  "query": {
    "filtered": {
      "query": {
        "match": {
          "name": "amh"
        }
      },
      "filter": {
        "term": {
          "stock": "426"
        } 
      }
    }
  }
}
#范围过滤器(范围过滤器execution参数，当范围值较大时
#fielddata能提高性能；范围较小时index更好)
GET products/_search
{ 
  "post_filter": {  
    "range": {
      "stock": { 
        "gt": 0,
        "lte": 400 
      }
    } 
  }
}

#exits过滤器可以过滤掉指定字段上没有值的文档
GET products/_search
{
  "post_filter": {
    "exists": {
      "field": "plain_content"
    }
  }
}
#missing过滤器可以过滤掉没有指定字段
#的文档或者指定字段为0的文档
GET products/_search
{
  "post_filter": {
    "missing": {
      "field": "title",
      "null_value": 0,
      "existence": true
    }
  }
}
#脚本过滤器
GET products/_search
{
  "post_filter": {
    "script": {
      "script": "newSales+doc['sales'].value>10",
      "params": {
        "newSales":10
      }
    }
  }
}
#类型过滤器
GET products/_search
{
  "post_filter": {
    "type": {
      "value": "product"
    }
  }
}
#限定过虑器(限定单个分片返回的文档数)
GET products/_search
{
  "post_filter": {
    "limit": {
      "value": 10
    }
  }
}
#标识符过滤器
GET products/_search
{
  "post_filter": {
    "ids": {
      "type":["product"],  
      "values":
      [
        "1","2","3"
      ]
    }
  }
}
#组合过滤器
GET products/_search
{
  "post_filter": {
    "not": {
      "and":
      [
        {
          "term":{
            "name":"amh"
          }
        },
        {
          "or":
          [ 
             {
               "term":{
                 "deleted":"false"
               }
             } 
          ]
        }
      ]
    }
  }
}
#命名过滤器
GET products/_search
{
  "query": {
    "filtered": {
      "query": {"match_all": {}},
      "filter": {
        "or": 
           {
             "and":
             [
                {
                  "term":{
                    "deleted":"false"
                  }
                }  
             ]
           }
      }
    }
  }
}
#命名过滤器
GET products/_search
{
  "query": {
    "filtered": {
      "query": {
        "match_all": {}
      },
      "filter": {
         "or":{
           "filters": [
             {
               "and": {
                 "filters": [
                   {
                     "term": {
                       "name": "amh",
                       "_name":"valid_name"
                     }
                   },
                   {
                     "term": {
                       "name": "韩版",
                       "_name":"valid_keywords"
                     }
                   }
                 ],
                 "_name":"valid_and"
               }
             },
             {
               "range": {
                 "sales": {
                   "gte": 10,
                   "lte": 200
                 },
                 "_name":"valid_sales"
               } 
             } 
           ],
           "_name":"valid_or"
         }
      }
    }
  }
}
#过滤器的缓存
#missing exists range term terms默认情况总是被缓存
GET products/_search
{
  "post_filter": {
    "script": {
      "_cache": true, 
      "script": "doc['stock'].value-newStocks>100",
      "params": {
        "newStocks":10
      }
    }
  }
}
#高亮显示(全局设置)
GET products/_search
{
  "query": {
    "match": {
      "name": "amh"
    }
  },
  "highlight": {
    "pre_tags": ["<b>"],
    "post_tags": ["</b>"],
    "fields": {
      "name": { 
      }
    }
  }
}
#高亮部分（局部设置）
GET products/_search
{
  "query": {
    "match": {
      "name": "amh"
    }
  },
  "highlight": {
    "fields": {
      "name": {
         "pre_tags": ["<b>"],
         "post_tags": ["</b>"]
      }
    }
  }
}
#高亮部分(多组合)
GET products/_search
{
  "query": {
    "match": {
      "name": "amh"
    }
  },
  "highlight": {
    "require_filed_match":"true",
    "fields": {
      "name": {
         "pre_tags": ["<b>"],
         "post_tags": ["</b>"]
      },
      "plain_content": {
         "pre_tags": ["<b>"],
         "post_tags": ["</b>"]
      }
    }
  }
}
#排序
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "created_at": {
        "order": "desc",
        "missing":1
      }
    }
  ]
}
#动态条件
#type表示脚本返回数据的类型
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "sort": {
    "_script":{
      "script":" doc['stock'].value>=0 ? doc['stock'].value : 0 ",
      "type":"string",
      "order":"asc"
    }
  }
} 
#多字段匹配
GET products/_search
{
  "query": {
    "terms": {
      "name": [
        "amh",
        "hstyle",
        "韩版"
      ],
      "minimum_match": 2
    }
  }
}
#创建树形索引
PUT path
{ 
  "settings": {
    "index":{
      "analysis":{
        "analyzer":{
          "path_analyzer":{
            "tokenizer":"path_hierarchy"
          }
        }
      }
    }
  },
  "mappings": {
    "catagory":{
      "properties": {
        "catagory":{
          "type":"string",
          "fields": {
            "name":{
              "type": "string",
              "index": "not_analyzed"
            },
            "path":{
              "type": "string",
              "analyzer": "path_analyzer",
              "store": true
            }
          }
        }
      }
    }
  }
}
#浏览树形结构
GET path/_analyze?field=catagory.path&text='/cars/passenger/sport'
#动态映射
#可以在elasticsearch.yml文件里设置index.mapper.dynamic
#=false关闭动态映射功能
#嵌套结构
PUT shop
{
  "mappings": {
    "colth":{
      "properties": {
        "name":{
          "type": "string",
          "index": "analyzed"
        },
        "variation":{
          "type": "nested",
          "properties": {
            "size":{
              "type":"string",
              "index":"not_analyzed"
            },
            "color":{
              "type":"string",
              "index":"not_analyzed"
            }
          }
        }
      }
    }
  }
}
#添加数据
PUT shop/colth/1
{
  "name":"test shirt",
  "variation":[
    {
      "size":"XXL","color":"red"    
    },
    {
      "size":"XL","color":"black"    
    }
  ]
}
#嵌套查询
#score_mode指定得分的计算方式
#[
#avg默认值 返回嵌套查询的平均值
#total返回嵌套查询得分的总和
#max 返回嵌套查询得分的最大值
#none 不计算得分
#]
GET shop/_search 
{
  "query": {
    "nested": {
      "path": "variation",
      "score_mode": "avg", 
      "query": {
        "bool": {
          "must": [
            {
              "term": {
                "variation.size": {
                  "value": "XXL"
                }
              }
            },
            { 
              "term": {
                "variation.color": {
                  "value": "black"
                }
              }
            }
          ]
        }
      }
    }
  }
}
#创建shop索引
POST shop
#构建父mapping
PUT shop/cloth/_mapping
{
  "cloth":{
    "properties":{
      "name":{
        "type":"string"
      }
    }
  }
}
#创建子mapping
PUT shop/variation/_mapping
{
  "variation":{
    "_parent":{
      "type":"cloth"
    },
    "properties":{
      "size":{
        "type":"string",
        "index":"not_analyzed"
      },
      "color":{
        "type":"string",
        "index":"not_analyzed"
      }
    }
  }
}
#构建索引的父子查询关系
POST shop/cloth/1
{
  "name":"test shirt"
}
POST shop/variation/1?parent=1
{
  "color":"black",
  "size":"XL"
}
POST shop/variation/1?parent=1
{
  "color":"red",
  "size":"XXL"
}
#has_child查询(查询子文档返回父文档)
GET  shop/_search
{
  "query": {
    "has_child": {
      "type": "variation",
      "query": {
        "bool": {
          "must": [
            {
              "term": {
                "size": {
                  "value": "XXL"
                }
              }
            },
            { 
              "term": {
                "color": {
                  "value": "red"
                }
              }
            }
          ]
        }
      }
    }
  }
}
#top_children
GET shop/_search
{
  "query": {
    "top_children": {
      "type": "variation",
      "query": {
        "term": {
          "size": {
            "value": "XXL"
          }
        }
      },
      "score": "max",
      "factor": 5,
      "incremental_factor": 2
    }
  }
}
#根据父文档得到子文档信息
GET shop/_search
{
  "query": {
    "has_parent": {
      "parent_type": "cloth",
      "query": {
        "term": {
          "name": {
            "value": "test"
          }
        }
      }
    }
  }
}
#拓展索引结构
POST users
#初始化mapping
PUT users/user/_mapping
{
  "user":{
    "properties":{
      "name":{
        "type":"string"
      }
    }
  }
}
#添加新的属性
PUT users/user/_mapping
{
  "user":{
    "properties":{
      "phone":{
        "type":"string",
        "store":"yes",
        "index":"not_analyzed"
      }
    }
  }
}
#脚本插件（需要安装相应的插件）
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "sort": {
   "_script":{
     "script":"1%100*_doc['sales']", 
     "type":"string",
     "order":"asc"
   } 
  }
}
#query查询
GET products/_search
{
  "query": {
    "match": {
      "name": {
        "query": "amh",
        "analyzer": "english"
      }
    }
  }
}
#更改文档得分
#constant_score查询
GET products/_search
{
  "query": {
    "constant_score": {
      "query": {
        "query_string": { 
          "query": "name:amh plain_content:韩版"
        }
      } 
    }
  }
}
#加权查询
GET products/_search
{
  "query": {
    "boosting": {
      "positive": {
        "match": {
          "name": "amh"
        }
      },
      "negative": {
        "match": {
          "name": "韩版"
        }
      },
      "negative_boost": 0.1
    }
  }
}
#function_score查询
#boost_mode参数允许定义如何将函数查询所计算分数与查询分#数结合起来,其值可以设置为一下任意一种
#multiply默认行为，查询得分将于函数计算得分相乘
#replace 忽略查询得分,文档得分等于函数计算得分
#sum 文档得分等于查询得分和函数得分之和
#avg 文档得分等于查询得分和函数得分的平均值
#max 文档得分等于查询得分和函数得分的最大值
#min  文档得分等于查询得分和函数得分的最小值
#score_mode改参数定义函数计算所得分如何结合在一起
#multiply默认行为,结果是查询得分乘以函数得分
#sum 把所有定义的函数的得分相加
#avg 函数得分等于所有匹配函数得分的平均值
#first把第一个拥有匹配文档过滤器的函数的得分返回
#max返回所有函数得分的最大值
#min返回所有函数得分的最小值
#boost_factor函数允许我们把文档分数乘以一个指定的值
#script_score函数允许我们使用一个脚本计算得分
#random_score函数允许我们指定一个seed值来生成一个伪随机数
GET products/_search
{
  "query": {
    "function_score": {
      "query": {
        "match": {
          "name": "amh"
        }
      },
      "boost_mode": "multiply",
      "score_mode": "multiply", 
      "functions": [
        {
          "boost_factor": 20
        }
      ]
    }
  }
}

GET products/_search
{
  "query": {
    "function_score": {
      "query": {
         "match": {
          "name": "amh"
        }
      },
      "functions": [
        {
          "script_score": {
            "script": "_score * parameter",
            "params": {
              "parameter":12
            }
          }
        }
      ]
    }
  }
}

GET products/_search
{
  "query": {
    "function_score": {
      "query": {
         "match": {
          "name": "amh"
        }
      },
      "functions": [
        {
           "random_score": {
             "seed": 314159265359
           }
        }
      ]
    }
  }
}
#
#同义词过滤器
#为了使用同义词过滤器，我们需要定义字节的分析器，称为
#synonym，使用空格分词和一个叫synonym的过滤器。该过滤器的类型属性必须设置为synonym，它告诉elasticsearch这是一个同#义词过滤器，如果忽略大小写则将ignore_case设置为true
#
# "index":{
#   "analysis":{
#    "analyzer":{
#      "synonym":{
#          "tokenizer":"whitespace",
#          "filter":["synonym"]
#        }
#      },
#      "filter":{
#        "synonym":{
#          "type":"synonym",
#          "ignore_case":true,
#          "synonyms":
#          [
#            "crime=>criminality"
#          ]
#        }
#      }
#    }
#  }
#
#通过文件引入同义词
#文件路径相对于config目录
#
#同义词映射形式
#many===one
#star wars,wars==>starwars
#one===many(使用其中一个单词来匹配包含其中一个单词的文档)
#star wars,wars,star,starwars
#
# "index":{
#   "analysis":{
#    "analyzer":{
#      "synonym":{
#          "tokenizer":"whitespace",
#          "filter":["synonym"]
#        }
#      },
#      "filter":{
#        "synonym":{
#          "type":"synonym",
#           "synonyms_path":"synonyms.txt"
#        }
#      }
#    }
#  } 
GET books/_search
#测试routing
#路由相同的索引会被建到一个分片上
PUT books
{
  "settings": {
    "number_of_replicas": 1,
    "number_of_shards": 25
  }, 
  "mappings": {
    "books": {
      "_routing": {
        "required": true 
      }, 
      "properties": {
        "id":{
          "type": "string",
          "index": "not_analyzed"
        },
        "title":{
          "type": "string",
          "index": "not_analyzed"
        },
        "version":{
          "type": "string",
          "index": "not_analyzed"
        },
        "category":{
          "type": "object",
          "index": "not_analyzed",
          "fields": {
            "id":{
              "type": "string",
              "index": "not_analyzed"
            },
            "name":{
               "type": "string",
               "index": "not_analyzed"
            }
          }
         }
      }
    }
  }
}
GET books/_search?routing=1
{
  "query": {
    "match_all": {}
  }
} 
POST books/book/1?routing=1
{
  "title":"slor",
  "version":"20150724",
  "category":{
    "id":"1",
    "name":"搜索丛书"
  } 
}
PUT books/book/2?routing=1 
{
  "title":"elasticsearch",
  "version":"20150724",
  "category":{
    "id":"1",
    "name":"搜索丛书"
  } 
}
PUT books/book/3?routing=2 
{
  "title":"java",
  "version":"20150724",
  "category":{
    "id":"2",
    "name":"语言丛书"
  } 
}

PUT books/book/4?routing=2
{
  "title":"ruby",
  "version":"20150725",
  "category":{
    "id":"2",
    "name":"语言丛书"
  }
}
PUT books/book/5?routing=2
{
  "title":"c++",
  "version":"20150725",
  "category":{
    "id":"2",
    "name":"语言丛书"
  }
}
PUT books/book/6?routing=2
{
  "title":"c++",
  "version":"20150726",
  "category":{
    "id":"2",
    "name":"语言丛书"
  }
}
PUT books/book/7?routing=2
{ 
  "title":"c++",
  "version":"20150726",
  "category":{
    "id":"2",
    "name":"语言丛书"
  }
}
#索引段合并
GET products/_optimize?only_expunge_deletes=true&wait_for_merge=false&max_num_segments=1
#elasticsearch.yml文件配置 
cluster.name: qfl
marvel.agent.enabled: true
script.groovy.sandbox.enabled: true
script.disable_dynamic: false  
#关闭http功能
http.enabled: false
#配置慢查询日志
index.search.slowlog.threshold.query.warn: 10s
index.search.slowlog.threshold.query.info: 5s
index.search.slowlog.threshold.query.debug: 2s
index.search.slowlog.threshold.query.trace: 500ms

index.search.slowlog.threshold.fetch.warn: 1s
index.search.slowlog.threshold.fetch.info: 800ms
index.search.slowlog.threshold.fetch.debug: 500ms
index.search.slowlog.threshold.fetch.trace: 200ms

index.indexing.slowlog.threshold.index.warn: 10s
index.indexing.slowlog.threshold.index.info: 5s
index.indexing.slowlog.threshold.index.debug: 2s
index.indexing.slowlog.threshold.index.trace: 500ms
#配置es线程池
threadpool:
    index:
        type: fixed
        size: 100
    search:
        type: fixed
        size: 1000 
#设置es分片数和副本数
index.number_of_shards: 5
index.number_of_shards: 1
#设置中文切词器
index:
  analysis:                   
    analyzer:      
      ik:
          alias: [ik_analyzer]
          type: org.elasticsearch.index.analysis.IkAnalyzerProvider
      ik_max_word:
          type: ik
          use_smart: false
      ik_smart:
          type: ik
          use_smart: true 
或者index.analysis.analyzer.default.type: "ik"

#node.master: false node.data: true该node服务器只作为一个数据节点，只用于存储索引数据。使该node服务器功能	单一，只用于数据存储和数据查询，降低其资源消耗率。
#node.master: true  node.data: false该node服务器只作为一个主节点，但不存储任何索引数据。该node服务器将使用	自身空闲的资源，来协调各种创建索引请求或者查询请求，讲这些请求合理分发到相关	的node服务器上。
#node.master: false node.data: false 该node服务器即不会被选作主节点，也不会存储任何索引数据。该服务器主要用	于查询负载均衡。在查询的时候，通常会涉及到从多个node服务器上查询数据，并请	求分发到多个指定的node服务器，并对各个node服务器返回的结果进行一个汇总处理，	最终返回给客户端。
#
#聚合
#stats返回聚合后的信息（不包括聚合字段）
#terms返回聚合后的信息（包括聚合字段）
#min max sum avg适用于数值类型的索引字段
GET products/_search
{
  "query": {
    "match_all": {
      
    }
  },
  "aggs": {
    "min_stocks":{
      "min": {
        "field": "stock"
      }
    },
    "max_stocks":{
      "max": {
        "field": "stock"
      }
    },
    "avg_stocks":{
      "avg": {
        "field": "stock"
      }
    },
    "sum_stocks":{
      "sum":{
        "field":"stock"
      }
    },
    "new_sales":{
      "max": {
        "script": "doc['sales'].value-100"
      }
    },
    "new_price":{
      "max": {
        "field": "anonymous_price",
        "script": "_value-20"
      }
    },
    "new_id":{
      "max": {
        "field": "id",
        "script": "_value-mod",
        "params": {
          "mod":20
        }
      }
    },
    "title_count":{
      "value_count": {
        "field": "name"
      }
    },
    "catagory": {
      "terms": {
        "field": "category.id"   
      }
    },
    "brand":{
      "stats": {
        "field": "brand.id"
      }
    }
  }
}
#stats和extend_stats聚合
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "sales": {
      "stats": {
        "field": "sales"
      }
    },
    "more_sales":{
        "extended_stats":{
          "field":"sales"
        }
      }
  }
}
#桶聚合
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "is_sale": {
      "terms": {
        "field": "stock",
        "size": 10,
        "order": {
          "_term": "asc"
        }
      }
    }
  }
}
#range聚合
GET products/_search
{
  "aggs": {
    "price": {
      "range": {
        "keyed": true, 
        "field": "sales",
        "ranges": [
          {"to": 50},
          {
            "from": 51,
            "to": 100
          },
          {
            "from": 150,
            "to": 200
          },
          {
            "from": 250,
            "to": 400
          },
          {
            "from": 401
          }
        ]
      }
    }
  }
}
#date_range聚合（专注于日期类型）
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "created_at_range": {
      "date_range": {
        "field": "created_at",
        "format": "dd-MM-yyy", 
        "ranges": [
          {
            "from": "2015-09-10"  
          },
          {
            "from": "2015-10-01",
            "to": "2015-10-31"
          } ,
          {
            "to": "2015-12-10"
          }
        ]
      }
    }
  }
}
#IPv4range聚合
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "access": {
      "ip_range": {
        "field": "ip", 
        "ranges": [
          {
            "from": "192.168.0.1",
            "to": "192.168.0.254"
          },
          {
            "mask": "192.168.1.0/24"
          }
        ]
      }
    }
  }
}
#missing聚合
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "missing_title": {
      "missing": {
        "field": "title"
      }
    }
  }
}
#nested聚合
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "variations": {
      "nested": {
        "path": "variation"
      }
    }
  }
}
#histogram聚合
#interval表示每个范围的周期
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "sales": {
      "histogram": {
        "field": "anonymous_price",
        "interval": 10
      }
    }
  }
}
#date_histogram聚合
#pre_zone(time_zone)
#设置小时偏移 pre_zone:-4
#设置时间格式 pre_zone:"-4:30"
#设置时区time_zone:"Europe/Warsam"
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "created_at_date": {
      "date_histogram": {
        "field": "created_at",
        "format": "yyyy-MM-dd HH:mm", 
        "interval": "10d"
      }
    }
  }
}
#geo_distance聚合(地图搜索)
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "neighborhood": {
      "geo_distance": {
        "field": "location",
        "ranges": [
          {
            "to": 100,
            "from": 150
          }
        ], 
        "origin": [-0.1275,51.507222]
      }
    }
  }
}
#unit表示距离单位（km公里、mi英里、in英寸、yd码、m、cm、mm）
#distance_type指定es的计算速度从最快但是精度最低到最慢但精度最高
#的可能值为plane、sloppy_arc、arc
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "neighborhood": {
      "geo_distance": 
      {
        "field": "location",
        "ranges": [
          {
            "to": 100,
            "from": 150
          }
        ], 
        "origin": {"lon":-0.1275,"lat":51.507222},
        "unit": "mi",
        "distance_type": "arc"
      }
    }
  }
}
#geohash_grid聚合
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "neighborhood": {
      "geohash_grid": 
      {
        "field": "location",
        "precision": 1
      }
    }
  }
} 
#聚合的嵌套
GET shop/_search
{
  "query": {
    "match_all": { 
    }
  },
  "aggs": {
    "variations": {
      "nested": {
        "path": "variation"
      },
      "aggs": {
        "sizes": {
          "terms": {
            "field": "variation.size" 
          }
        }
      }
    }
  }
}
#桶排序和嵌套聚合
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "sales": {
      "terms": {
        "field": "sales",
        "order": {
          "numbers.avg":"asc"
        }
      },
      "aggs": {
        "numbers": {
          "stats": {}
        }
      }
    }
  }
}
#全局和子集
GET products/_search
{
  "query": {
    "filtered": {
      "query": {
        "match_all": {}
      },
      "filter": {
        "term": {
          "displayed": "true"
        }
      }
    }
  },
  "aggs": {
    "with_group": {
      "global": {},
      "aggs": {
        "brand_id": {
          "value_count": {
            "field": "brand.id"
          }
        }
      }
    },
    "without_group":{
      "value_count": {
        "field": "brand.id"
      }
    }
  }
}
#包含和排除
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "avaiability": {
      "terms": {
        "field": "name",
        "include": "amh",
        "exclude": "hstyle"
      }
    }
  }
}
#使用查询进行切面计算
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "my_query_facet": {
      "query": {
        "term": {
          "category.id": {
            "value": "19"
          }
        }
      }
    }
  }
}
#使用过滤器进行切面计算
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "my_filter_facet": {
      "filter": {
        "term": {
          "category.id": "19"
        }
      }
    }
  }
}
#terms切面
#
#size参数指定最多返回多少个最频繁的词条
#order指定切面的顺序（count按照频率降序排序、term按字母升序、  #reverse_count按词频率升序排序 reverse_term按字母降序排序）
#shard_size指定查询的节点上每个分片获取的结果数
#all_terms返回所有词条
#exclude指定一组词条，他们将从切面计算中被删除
#regex指定一个正则表达式，用于计算切面中的词条
#script指定一个脚本用于计算切面中的词条
#fields指定一个数组，用于计算切面中的词条
#_script_field指定一个脚本用于计算实际词条
#
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "my_facets":
    {
      "terms": {
        "field": "category.id"  
      }
    }
  }
}
#基于范围的切面
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "range_facet_result": {
      "range": {
        "field": "anonymous_price",
        "ranges": [
          {
            "to": 50
          },
          {
            "from": 20,
            "to": 70
          },
          {
            "from": 70,
            "to": 120
          },
          {
            "from": 150
          }
        ]
      }
    }
  }
}
#数值和日期直方图切面
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "total_histogram": {
      "histogram": {
        "field": "price_with_user_rank_id_1",
        "interval": 100
      }
    }
  }
}
#数值型字段统计
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "statistical_test": {
      "statistical": {
        "field": "sales"
      }
    }
  }
}
#词条统计数量
#key_field包含提供词条的名字
#value_field包含数值字段的名字
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "total_price_stats": {
      "terms_stats": {
        "key_field": "brand.id",
        "value_field": "sales"
      }
    }
  }
}
#地理切面
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "spatial_test": {
      "geo_distance": {
        "location":{
          "lat":10.0,
          "lon":10.0
        },
        "range":[
          {"to":10},
          {"from":10,"to":100},
          {"from":100}
          ]
      }
    }
  }
}
#过滤切面结果
GET products/_search
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "sales": {
      "terms": {
        "field": "sales",
        "size": 10
      },
      "facet_filter": {
        "term": {
          "sales": 0
        }
      }
    }
  }
}
#包含建议器（term）
#text该参数定义我们希望得到建议的文本
#feild设置为哪个字段生成建议
#analyzer定义用作分析text文本的分析器，如果没设置默认使用#field字段指定的分析器
#size默认为5，指定text参数中每个词条返回的最大数字
#sort指定如何排序，默认score（首先按建议的得分，然后按文#档频率，最后按词条）也可以设置为freauency(首先按文档频率#其次按得分，最后按词条)
#lowercase_terms当设置为true时，返回词条转为小写
#shard_size设置每个分片应该读取的最大数量
#prefix_len默认值为1，增加这个值可以提供性能
#min_word_len默认4，指定返回的建议列表中词条的最少字符数
GET products/_search
{
  "query": {
    "match_all": { 
    }
  },
  "suggest":{
    "text":"amkh",
    "first_suggestion":{ 
      "term":{
        "field":"_all"
      }
    },
      "second_suggestion":{
        "term":{
          "field":"name"
        }
      }
  }
}
#phrase建议器(基于term建议器)
#max_errors次选项指定可纠错的短语中包含错误词条的最大数目#可以设置整数和小数（看成百分比）
#separator默认是空白符，指定用来在结果集字段中分割词条的#分隔符
#
GET products/_search
{
   "suggest":{
     "text":"amsh",
     "our_suggestion":{
       "phrase":{
         "field":"_all"
       }
     }
   }
}
#completion建议器
#weight表示权重 值越高 建议越重要
GET authors/_mapping
DELETE authors
PUT authors
{
  "mappings":{
    "author":{
      "properties":{
        "name":{"type":"string"},
        "ac":{
          "type":"completion",
          "index_analyzer":"simple",
          "search_analyzer":"simple",
          "payloads":true
        }
      }
    }
  }
}
#索引数据
PUT authors/author/1
{
  "name":"Fyodor Dostoevsky",
  "ac":{
    "input":["fyodor","dostoevsky"],
    "output":"Fyodor Dostoevsky",
    "payload":{
      "books":["123456","123457"]
    },
    "weight":20
  }
}
PUT authors/author/2
{
  "name":"Joseph Conrad",
  "ac":{
    "input":["joseph","conrad"],
    "output":"Joseph Conrad",
    "payload":{
      "books":["123456","123457"]
    },
    "weight":30
  }
}
#搜索
GET authors/_suggest
{
  "authorsAutocomplete":{
    "text":"fio",
    "completion":{
      "field":"ac",
      "fuzzy":{
        "edit_distance":2
      }
    }
  }
}
#预编译(注册查询语句 通过商品搜索查询语句)
PUT notifier/.percolator/1
{
  "query": {
    "bool": {
      "must":  
        {
          "term": {
            "title": {
              "value": "crime"
            }
          }
        }, 
        "should":  
          {
            "range":{
              "year":{
                "gt":1900,
                "lt":2000
              }
            }
          } ,
          "must_not": 
            {
              "term":{
                "otitle":"nothing"
              }
            } 
    }
  }
}
PUT notifier/.percolator/old_books
{
  "query": {
    "filtered": {
      "query": {
        "range": {
          "year": {
            "gte": 2015,
            "lte": 2020
          }
        }
      },
      "filter": {
        "term":{
          "available":true
        }
      }
    }
  }
}
PUT /notifier/book/_percolate
{
  "doc":{
    "title":"Crime and Punishment",
    "otitle":"sdsad",
    "author":"Fyodor Dostoevsky",
    "year":1886,
    "tags":[],
    "available":true
  }
}
#文件的处理
#首先安装attachments插件
PUT file
{
  "mappings": {
    "file":{
      "properties": {
        "note":{"type": "string","store":"yes"},
        "book":{
          "type": "attachment",
          "fields": {
            "file":{"index": "analyzed","store":"yes" },
            "date":{"store": true},
            "author":{"store": true},
            "keywords":{"store": true},
            "content_type":{"store": true},
            "title":{"store": true}
          }
        }
      }
    }
  }
}
#想索引里添加文件内容（文件内容必须使用base64算法编码）
PUT /file/page/1
{
  "note":"just a note",
  "book":"this is an example document for 'es' book",
  "_name":"elasticsearch" 
}
#搜索改文件
GET file/_search
{
  "query": {
    "term": {
      "book": {
        "value": "example"
      }
    }
  },
  "fields": ["title","author","date","keywords","note","content_type"]
}
DELETE poi
GET poi/_search
GET poi/_mapping
#地理位置搜索
PUT /poi
{
  "mappings": {
    "poi":{
      "properties": {
        "name":{"type": "string"},
        "location":{"type": "geo_point"}
      }
    }
  }
}
#索引数据
PUT poi/poi/1
{
  "name":"New York",
  "location":"40.664167,-73.938611"
}
PUT poi/poi/2
{
  "name":"London",
  "location":[-0.12664167,51.938611]
}
PUT poi/poi/3
{
  "name":"Moscow",
  "location":{"lat":40.664167,"lon":-73.938611}
}
PUT poi/poi/4
{
  "name":"Sydney",
  "location":"-33.664167,173.938611"
}
#按照与给定点的距离对结果进行排序
GET poi/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "_geo_distance": {
        "location": "48.8567,2.3508",
        "unit": "km"
      }
    }
  ]
}
#边界框过滤
GET poi/_search
{
  "query": {
    "match_all": {}
  },
  "filter": {
    "geo_bounding_box": {
      "location": {
        "top_left": {
          "lat": 52.73,
          "lon": -1.1
        },
        "bottom_right": {
          "lat": 48.717,
          "lon": 3.99
        }
      }
    }
  }
}
#距离的限制
GET poi/_search
{
  "query": {
    "match_all": {}
  },
  "filter": {
    "geo_distance": {
      "location": { 
          "lat": 40.664167,
          "lon": -73.938611
      },
      "distance":"500km"
    }
  }
}
DELETE map
GET map
#任意地图形状
PUT /map
{
  "mappings": {
    "map":{
      "properties": {
        "name":{"type": "string","index": "not_analyzed"},
        "location":{"type": "geo_shape"}
      }
    }
  }
}
#构造一个点
PUT map/map/1
{
  "name":"Sydney",
  "location":{
    "type":"point",
    "coordinates":[-73.938611,40.664167]
  }
}
#构造一个包路线
PUT map/map/2
{
  "name":"London", 
    "type":"envelope",
    "coordinates":
    [
      [-73.938611,40.664167],
      [2.41699921875,48.80686346108517]
    ]
  
}
#多边形
PUT map/map/3
{
    "name":"Lisbon", 
    "type":"polygon",
    "coordinates":[[
      [-5.938611,49.664167],
      [-7.41699921875,55.80686346108517],
      [1.34561,51.6952],
      [-5.3695,49.325778]
      ]]
  
}
#多个多边形
PUT map/map/4
{
    "name":"Moscow", 
    "type":"multipolygon",
    "coordinates":[
      [[
        [-5.938611,49.664167],
        [-7.41699921875,55.80686346108517],
        [1.34561,51.6952],
        [-5.3695,49.325778]
      ]],
     [[
          [-0.938611,41.664167],
          [-4.41699921875,66.80686346108517],
          [5.34561,58.6952],
          [-3.3695,46.325778]
      ]] 
  ]
}
 #卷动api卷动api可以建议es对结果集保存多少时间
GET products/_search?scroll=5m
{
  "query": {
    "match_all": {}
  }
}
#多词条过滤器
GET products/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "terms": {
          "name": [
            "amh",
            "style"
          ]
        }
      },
      "boost": 1.2
    }
  }
}
DELETE  books
#词条查找
PUT books/book/1
{
  "id":1,
  "name":"test book 1",
  "similar":[2,3]
}
PUT books/book/2
{
  "id":2,
  "name":"test book 2",
  "similar":[1]
}
PUT books/book/3
{
  "id":3,
  "name":"test book 3",
  "similar":[1,3]
}
GET books/_search
{
  "query": {
    "filtered": {
      "query": {
        "match_all": {}
      },
      "filter": {
        "terms": {
          "id": {
            "index":"books",
            "type":"book",
            "id":"3",
            "path":"similar"
          },
          "_cache_key":"books_3_similar"
        }
      }
    }
  }
  ,
  "fields": ["id","name"]
}
#测试ik分词器
PUT tests
{
  "name":"ssss"
}
GET /tests/_analyze?analyzer=ik&pretty=true
{
"text":"世界如此之大"
}
#创建索引存储库
#配置es快照门（在elasticsearch.yml中）
#path.repo: "/temp/es_backup"（指定的文件夹 必须是共享文件（释放文件的权限））
#创建一个快照存储库
PUT /_snapshot/backup
{
  "type":"fs",
  "settings":{
    "location":"/temp/es_backup"
  }
}
#查询所有存储库
GET /_snapshot/_all
#查询指定的存储库
GET /_snapshot/backup
#删除存储库
DELETE /_snapshot/backup 
#
#快照库其他参数
#name快照库的名字（唯一标识）
#type存储库类型（fs共享文件的存储库 url通过url访问的存储库）
#settings存储额外信息
#indices要备份到快照库的索引名字
#ignore_unavailable(默认true)当设置为false时意味着如果indices参数指向的索引不存在则命令执行失败
#include_global_state（默认为true）意味着集群状态也被写的快照
#partial快照的成功与否取决于所有分片的可用性
GET products/_search
{
  "query": {
    "match_all": {}
  }
}
#备份products索引
PUT /_snapshot/backup/products_snap?wait_for_completion=true
{
  "indices":"products",
  "include_global_state":false
}
#得到备份库
GET /_snapshot/backup/products_snap
#删除快照库
DELETE /_snapshot/backup/products_snap

DELETE products
GET products/_search
{
  "query": {
    "match_all": {}
  }
}
#快照还原（还原快照中存储的所有索引）
POST  /_snapshot/backup/products_snap/_restore 
#还原指定名称的索引
POST  /_snapshot/backup/products_snap/_restore 
{
  "indices": "products"
}
#可选参数
#ignore_unavailable与创建快照时相同
#include_global_state与创建快照时相同
#rename_pattern允许改变存储在快照中的索引的名称
#集群的健康度
GET _cluster/health?pretty
#参数解释
#当所有分片和副本都分配好集群为green
#当主分片分配但是部分副本或者所有副本还没有集群为yellow
#当集群为准备好显示为red
#检查指定索引的健康状况
GET /_cluster/health/products
#额外参数level可以指定为clustor、indices、shards
#level=indices返回索引信息
#level=clustor(默认)返回集群节点信息
#level=shards返回分片信息
#timeout相应时间
#wait_for_status(可以设置为green、yellow、red)返回指定状态的信息
#wait_for_nodes允许设置返回响应时需要多少节点可用
GET /_cluster/health?wait_for_sattus=yellow&timeout=10s&wait_for_nodes>=3
#索引统计api
GET /products/_stats（可以得到指定索引的所有信息）
#相关信息详解
#docs节点显示索引文档的信息
#store提供关于存储的信息
#indexing/get/search提供数据操作的信息
#merges包含luence段合并的信息
#refresh包含刷新操作的信息
#flush包含清除信息
#warmer包含预热信息
#filter_cache包含过滤器缓存统计信息
#id_cache标识符缓存统计信息
#fielddata字段数据缓存统计信息
#percolate包含预匹配去使用情况信息
#completion包含自动完成建议器的信息
#segments包含luence段的信息
#translog包含事务日志计数和大小的信息
#状态api(获得指定索引的状态)
GET /products/_status
#节点信息api（节点信息api提供了关于集群中节点的信息） 
#获取节点的指定信息
GET /_nodes/es_node/os,jvm,plugins
#settings获取elasticsearch配置信息
#os获取服务器信息
#process获取进程标识符和可用的文件描述信息
#jvm获取java虚拟机信息
#thread_pool获取线程池信息
#network获取网络接口名称和地址
#http获取http监听地址
#plugins获取安装插件信息
#tranport获取传输的监听接口信息 
#节点统计API(记录集群工作过程)
GET /_nodes/es_node/stats
#indices提供关于索引的信息
#os提供操作系统的信息
#process提供跟elasticsearch进程相关的信息
#jvm提供关于java虚拟机内存和垃圾回收的信息
#network提供tcp级别的信息
#transport提供传输模板块发送和接收的信息
#http提供http链接信息
#fs提供可用磁盘空间和读写操作的统计信息
#thread_pool提供分配给各种操作线程的状态信息
#breaker提供字段数据缓存断路器信息
GET /_nodes/es_node/stats/os,jvm,plugins,network,thread_pool,settings
#集群状态API()
#获得指定节点的所有信息
GET /_cluster/state
#返回节点信息
GET /_cluster/state/nodes
#获得集群状态版本信息
GET /_cluster/state/version
#获取主节点的信息
GET /_cluster/state/master_node
#获得路由信息
GET /_cluster/state/routing_table
#返回元数据信息
GET /_cluster/state/metadata
#返回块信息
GET /_cluster/state/blocks
#挂起任务API(查看一组任务)
GET /_cluster/pending_tasks
#索引段API
GET /_segments
#cat API
#返回分片信息
GET /_cat/shards?v
#返回别名信息
GET /_cat/aliases?v
#为所有索引或单个索引返回文档个数的信息
GET /_cat/count?v
#返回分片分配和磁盘使用的信息
GET /_cat/allocation?v
#返回集群健康的信息
GET /_cat/health?v
#返回所有索引和单个索引的信息
GET /_cat/indices?v
#返回当选主节点的信息
GET /_cat/master?v
#返回集群拓扑相关信息
GET /_cat/nodes?v
#返回正在等待执行的任务的信息
GET /_cat/pending_tasks?v
#返回还原过程的视图
GET /_cat/recovery?v
#返回集群范围内的线程池统计信息
GET /_cat/thread_pool?v 
#集群的再平衡设置
#控制再平衡开始的时间
#cluster.routing.allocation.allow_rebalance可选值如下
#always该值表明再平衡可以在需要的时候随时开始
#indices_primaries_active该值表明当所有的主分片初始化后开始再平衡
#indices_all_active（默认值）表示所有分片和副本都初始化后开始再平衡
#控制同时在节点中移动的分片数量
#cluster.routing.allocation.cluster_concurrent_rebalance(默认为2)属性指定整个集群中可以同时在节点间移动的分片数量
#控制单个节点上同时初始化的分片数量
#cluster.routing.allocation.node_concurrent_recoveries(默认为2)属性可以设置单个节点上一次可以初始化多少分片
#控制单个节点上同时初始化的主分片数量
#cluster.routing.allocation.node_initial_primaries_recoveries属性可以设置单个节点上一次可以初始化多少主分片
#控制分配的分片类型
#cluster.routing.allocation.enabled属性可以设置分配哪种类型的分片
#all（默认值）允许所有类型分片
#none禁用分片分配
#new_primaries只分配新创建的分片
#primaries只分配主分片不分配副本
#控制分片和副本的分配
#在节点中配置分区（elasticsearch.yml中）
#节点一中node.zone: zone_one
#节点二中node.zone: zone_two
#将索引创建到指定分区
PUT /shop
{
  "settings": {
    "index":{
      "routing.allocation.include.zone":"zone_one"
    }
  }
}
PUT /users
{
  "settings": {
    "index":{
      "routing.allocation.include.zone":"zone_two"
    }
  }
}
POST /promotions
PUT /promotions/_settings
{
   "index.routing.allocation.include.zone":"zone_one,zone_two"
} 
#移除节点的分配
PUT /promotions/_settings
{
   "index.routing.allocation.exclude.zone":"zone_one"
}
#节点需求属性
#index.routing.allocation.required.zone指定分片必须匹配某种规则才能分配到指定节点
#index.routing.allocation.include.zone满足一个指定条件即可分配
PUT /promotions/_settings
{
   "index.routing.allocation.required.size":"big_size",
   "index.routing.allocation.required.zone":"zone_one"
} 
#使用ip地址分配
PUT /promotions/_settings
{
   "index.routing.allocation.include._ip":"10.1.2.10,10.1.2.11"
} 
#基于磁盘的分片分配
#启用基于磁盘的分片分配
PUT /_cluster/settings
{
  "transient": {
    "cluster": {
      "routing": {
        "allocation.disk.threshold_enabled": true
      }
    }
  }
}
#配置基于磁盘的分片分配
#cluster.info.update.interval(默认30s)定义elasticsearch更新节点上磁盘使用信息的时间间隔
#cluster.routing.allocation.disk.watermark.low定义当磁盘空间被使用超过70%的节点不会被分配新的分片
#cluster.routing.allocation.disk.watermark.high定义当磁盘空间被使用大于或等于85%的节点会被重新分配分片
#设置集群范围的分配
PUT /_cluster/_settings
{
   "transient":{
     "cluster.routing.allocation.include._ip":"10.1.2.10,10.1.2.11"
   } 
} 
#设置指定索引最多可以放置多少分片
PUT /products/_settings
{
  "index": {
    "routing": {
      "allocation": {
        "total_shards_per_node": 1
      }
    }
  }
}
#手动移动分片和副本
POST /_cluster/reroute
{
  "commands": [
    {
      "move": {
        "index": "index_name",
        "shard": 1,
        "from_node": "es_node_name",
        "to_node": "es_node_name"
      }
    }
  ]
}
#参数详解
#move命令允许移动由index属性指定的索引的分片和副本
#shard属性是要移动的分片的编号
#from_node指定从哪个节点移动
#to_node指定移动到哪个节点
#取消节点的移动
POST /_cluster/reroute
{
  "commands": [
    {
      "cancel": {
        "index": "index_name",
        "shard": 0,
        "node": "es_node_one"
      }
    }
  ]
}
#上述命令将取消es_node_one节点上shop索引编号为0的分片的分配
#分配分片
POST /_cluster/reroute
{
  "commands": [
    {
      "allocate": {
        "index": "index_name",
        "shard": 0,
        "node": "es_node_one"
      }
    }
  ]
}
#以上命令将编号为0的未分配的分片分配到es_node_one节点上
#批量操作
POST /_cluster/reroute
{
  "commands": [
    {
      "move": {
        "index": "",
        "shard": 0,
        "from_node": "",
        "to_node": ""
      }
    },
    {
      "cancel": {
        "index": "",
        "shard": 0,
        "node": ""
      }
    }
  ]
}
#定义一个预热查询
PUT /products/product/_warmer/query_all
{
  "query": {
    "match_all": {}
  },
  "facets": {
    "product_shop_categories_facet":{
      "terms": {
        "field": "product_shop_categories.name" 
      }
    }
  }
}
#预热查询的作用是添加一个预热查询后，elasticsearch允许一个新段执行搜索前，先执行预热查询
#获取指定索引类型下的预热查询
GET /products/product/_warmer/query_all
#获取所有的预热查询
GET /products/_warmer
#获取以query_开头的预热查询
GET /products/_warmer/query_*
#删除指定索引下的全部预热查询
DELETE /products/_warmer/_all
#删除指定的预热查询
DELETE /products/_warmer/query_all
#删除有通配符的预热查询
DELETE /products/_warmer/product_*
#禁用预热查询
PUT /products/_settings
{
  "index.warmer.enabled": false
}
#索引别名
#创建别名
POST _aliases
{
  "actions": [
    {
      "add": {
        "index": "products",
        "alias": "snap"
      }
    }
  ]
}
#移除别名
POST _aliases
{
  "actions": [
    {
      "remove": {
        "index": "products",
        "alias": "snap"
      }
    }
  ]
}
#合并操作
POST /_aliases
{
  "actions": [
    {
       "add": {
        "index": "products",
        "alias": "snap"
      }
    },
     {
      "remove": {
        "index": "products",
        "alias": "snap"
      }
    }
  ]
}
#获取所有别名
GET /_aliases
#获得指定索引的别名
GET products/_aliases
#删除别名
DELETE /products/_alias/snap
#别名中的过滤
POST /_aliases
{
  "actions": [
    {
      "add": {
        "index": "index_name",
        "alias": "alias",
        "filter": {
          "term": {
            "clientId": "123456"
          }
        }
      }
    }
  ]
}
#以上命令执行后，当使用该别名时，你的请求将总会被一个词条过滤，确保所有文档的clientId为123456
#别名和路由
#使用场景（假设我们在使用基于用户标识符的路由，且想在别名中使用相同的路由值，则可以在名为client的别名中，我们将在查询时使用123，在索引时使用456） 
POST /_aliases
{
  "actions": [
    {
      "add": {
        "index": "data",
        "alias": "client",
        "search_routing": "123",
        "index_routing": "456"
      }
    }
  ]
}
#elasticsearch在线插件安装插件
#bin/plugin -i plugin_name
#移除插件 
#bin/plugin -r plugin_name
#安装本地插件
#bin/plugin -i -url file:///temp/plugin_name
#更新设置API
#(下次重启后失效)
PUT /_cluster/settings
{
  "transient": {
    "property_name":"property_value"
  }
}
#永久不失效
PUT /_cluster/settings
{
  "persistent": {
    "property_name":"property_value"
  }
}
#查看设置
GET /_cluster/settings
#
#elasticsearch集群
#配置主节点和数据节点
#默认情况下一个节点同时成为主节点和数据节点
#node.data:true node.master:false 数据节点
#node.data:false node.master:true 主节点 
#discovery.zen.minimum_master_nodes属性定义为形成一个集群，有主节点资#格并且相互连接的节点的最小数目(可以设置为 集群数量*0.5+1)
#设置集群名称cluster.name默认elasticsearch
#设置节点的ping
#discovery.zen.fd.ping_interval默认1s，指定节点相互ping的时间间隔
#discovery.zen.fd.ping_timeout默认30s指定节点发送ping信息后的等待时间
#discovery.zen.fd.ping_retries默认3指定重试次数
#设置单播主机
#discovery.zen.ping.unicast.hosts:192.168.2.1:[9300-9399]
#,192.168.2.1:9200
#配置多播
#discovery.zen.ping.multicast.group用于多播请求的群组地址
#discovery.zen.ping.multicast.port用于多播通信的端口号
#discovery.zen.ping.multicast.ttl多播请求被认为有用的时间
#discovery.zen.ping.multicast.address elasticsearch默认绑定的地址
#discovery.zen.ping.unicast.hosts指定所有形成集群的主机
#节点的ping设置
#discovery.zen.fd.ping_interval指定节点间相互ping的时间间隔
#discovery.zen.fd.ping_timeout指定节点发送ping后等待响应的时间
#discovery.zen.fd.ping_retries指定重试次数，超过此次数则认为节点停止工作
#elasticsearch时光之门（用来持久化索引）
#gateway.type=local默认使用本地进行持久化（elasticsearch也推荐使用本地）
#gateway.recover_after_nodes指定多少个有资格成为主节点的节点在集群中出现时才开始启动恢复
#gateway.recover_after_time指定我们希望集群形成后多少分钟开始恢复
#gateway.expected_nodes指定当集群中节点的数目等于多少时elasticsearch将立即开始恢复
#elasticsearch集群调优(配置elasticsearch.yml文件)
# 锁定内存，不让JVM写入swapping，避免降低ES的性能
#bootstrap.mlockall: true
# 缓存类型设置为Soft Reference，只有当内存不够时才会进行回收
#index.cache.field.max_size: 50000
#index.cache.field.expire: 10m
#index.cache.field.type: soft
#节点过滤器缓存
#indices.cache.filter.size
#字段数据缓存
#indices.fielddata.cache.size用于控制字段缓存
#断路器
#indices.fileddata.breaker.limit=0.8
#当查询导致加载字段的值所需要的内存超过elasticsearch进程可以内存的80%时#将引发一个异常
#索引的存储模块
#index.store.type
#simplefs基于磁盘的存取，使用随机文件来访问（并发性不好）
#niofs基于磁盘的索引存储（高并发性很好）
#mmapfs这是一个基于磁盘的存储，在内存中映射索引文件
#memory这将把索引存储在内存中
#索引缓冲
#indices.memory.index_buffer_size控制所有索引的分片共同拥有的最大内存大小（或者最大堆内存的百分比）
#indices.memory.min_shard_index_buffer_size默认4mb设置每个分片最小索引缓冲
#索引刷新率
#index.refresh_interval(默认1s)
#配置elasticsearch线程池
#threadpool.index.type 指定线程池创建的类型
#cache无限制的线程池
#fixed固定大小的线程池
#threadpool.index.size指定线程池大小
#threadpool.index.queue_size指定线程池队列大小
#线程池类型：
#index此线程池用来索引和删除操作
#search此线程池用于搜索和计数请求
#suggest此线程池用于建议器请求
#get此线程池用于实时的get请求
#bulk此线程池用于批量处理
#percolate此线程池用于与匹配器操作
#优化事务日志（推荐设置为默认值的10倍）
#index.translog.flush_threshlod_ops指定事务日志保存最多次操作数（默认5000次）
#index.translog.flush_threshlod_size指定事务日志的大小（默认200mb）
#elasticsearch JVM调优（修改elasticsearch的./bin/elasticsearch.in.sh文件）
## 一般分配主机1/4-1/2的内存
#if [ "x$ES_MIN_MEM" = "x" ]; then
#    ES_MIN_MEM=2g
#fi
#if [ "x$ES_MAX_MEM" = "x" ]; then
#    ES_MAX_MEM=4g
#fi 
#JAVA_OPTS="$JAVA_OPTS -Xms${ES_MIN_MEM}"
#JAVA_OPTS="$JAVA_OPTS -Xmx${ES_MAX_MEM}"
# 线程大小, ES单线程承载的数据量比较大
#JAVA_OPTS="$JAVA_OPTS -Xss128m"
#elasticsearch模板
#template名字设置为*意味着匹配所有索引名
#template名字设置为ha_*意味着匹配所有索引名以ha_开头的索引
#template名字相同时则启用order，order值越大权重越高
PUT /_template/main_template
{
  "template": "*",
  "order":1,
  "settings": {
    "index.number_of_replicas":0
  },
  "mappings": {
    "_default_":{
      "_source":{
        "enabled":false
      }
    }
  }
}
PUT /_template/ha_template
{
  "template": "ha_*",
  "order":10,
  "settings": {
    "index.number_of_replicas":5
  }
}
PUT ha_tests/test/1
{
  "name":"sss"
}
GET ha_tests/_settings
GET ha_tests/_mapping
#动态模板
#动态模板可以定义自己的模式，并将其应用于文档的字段名称上
#如果字段名和模式名相匹配则使用该mapping
#
PUT /_template
{
  "mappings":{
    "article":{
      "dynamic_template":[
        "template_test":{
          "match":"*",
          "mapping":{
            "index":"not_analyzed",
            "fields":{
              "str":{
                "type":"{dynamic_type}",
                "index":"not_analyzed"
              }
            }
          }
        }
        ]
    }
  }
}
elasticsearch详细配置说明
cluster.name: elasticsearch
配置es的集群名称，默认是elasticsearch，es会自动发现在同一网段下的es，如果在同一网段下有多个集群，就可以用这个属性来区分不同的集群。

node.name: "Franz Kafka"
节点名，默认随机指定一个name列表中名字，该列表在es的jar包中config文件夹里name.txt文件中，其中有很多作者添加的有趣名字。

node.master: true
指定该节点是否有资格被选举成为node，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master。

node.data: true
指定该节点是否存储索引数据，默认为true。

index.number_of_shards: 5
设置默认索引分片个数，默认为5片。

index.number_of_replicas: 1
设置默认索引副本个数，默认为1个副本。

path.conf: /path/to/conf
设置配置文件的存储路径，默认是es根目录下的config文件夹。

path.data: /path/to/data
设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开，例：
path.data: /path/to/data1,/path/to/data2

path.work: /path/to/work
设置临时文件的存储路径，默认是es根目录下的work文件夹。

path.logs: /path/to/logs
设置日志文件的存储路径，默认是es根目录下的logs文件夹

path.plugins: /path/to/plugins
设置插件的存放路径，默认是es根目录下的plugins文件夹

bootstrap.mlockall: true
设置为true来锁住内存。因为当jvm开始swapping时es的效率 会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。 同时也要允许elasticsearch的进程可以锁住内存，linux下可以通过`ulimit -l unlimited`命令。

network.bind_host: 192.168.0.1
设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0。


network.publish_host: 192.168.0.1
设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。

network.host: 192.168.0.1
这个参数是用来同时设置bind_host和publish_host上面两个参数。

transport.tcp.port: 9300
设置节点间交互的tcp端口，默认是9300。

transport.tcp.compress: true
设置是否压缩tcp传输时的数据，默认为false，不压缩。

http.port: 9200
设置对外服务的http端口，默认为9200。

http.max_content_length: 100mb
设置内容的最大容量，默认100mb

http.enabled: false
是否使用http协议对外提供服务，默认为true，开启。

gateway.type: local
gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的HDFS，和amazon的s3服务器，其它文件系统的设置方法下次再详细说。

gateway.recover_after_nodes: 1
设置集群中N个节点启动时进行数据恢复，默认为1。

gateway.recover_after_time: 5m
设置初始化数据恢复进程的超时时间，默认是5分钟。

gateway.expected_nodes: 2
设置这个集群中节点的数量，默认为2，一旦这N个节点启动，就会立即进行数据恢复。

cluster.routing.allocation.node_initial_primaries_recoveries: 4
初始化数据恢复时，并发恢复线程的个数，默认为4。

cluster.routing.allocation.node_concurrent_recoveries: 2
添加删除节点或负载均衡时并发恢复线程的个数，默认为4。

indices.recovery.max_size_per_sec: 0
设置数据恢复时限制的带宽，如入100mb，默认为0，即无限制。

indices.recovery.concurrent_streams: 5
设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。

discovery.zen.minimum_master_nodes: 1
设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4）

discovery.zen.ping.timeout: 3s
设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。

discovery.zen.ping.multicast.enabled: false
设置是否打开多播发现节点，默认是true。

discovery.zen.ping.unicast.hosts: ["host1", "host2:port", "host3[portX-portY]"]
设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。

下面是一些查询时的慢日志参数设置
index.search.slowlog.level: TRACE
index.search.slowlog.threshold.query.warn: 10s
index.search.slowlog.threshold.query.info: 5s
index.search.slowlog.threshold.query.debug: 2s
index.search.slowlog.threshold.query.trace: 500ms

index.search.slowlog.threshold.fetch.warn: 1s
index.search.slowlog.threshold.fetch.info: 800ms
index.search.slowlog.threshold.fetch.debug:500ms
index.search.slowlog.threshold.fetch.trace: 200ms
#elasticsearch常用插件
Marvel是Elasticsearch的管理和监控工具，在开发环境下免费使用
安装方法，进入elasticsearch的bin执行plugin -i elasticsearch/marvel/latest安装
删除plugin -i elasticsearch/marvel/latest
























