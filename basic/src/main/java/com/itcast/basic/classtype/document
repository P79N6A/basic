

/**
 * Created by qfl on 16/4/21.
 * 对Java程序执行的思考:
 *              java源文件
 *                  |------------编译器
 *              class二进制文件
 *                  |
 *   -------------------------------------------                          ---------------------------------------------
 *   |                                          |                         |                                            |
 *   |  ClassLoader---------->执行引擎           |                         |                                            |
 *   |       |                 ^                |    运行时数据区结构       |   栈         本地方法栈                      |
 *   |       |                 |                |  -------------------->  |                                            |
 *   |       -------------------------          |                         |                                            |
 *   |       |       运行时数据区       |         |                         |  程序计数器   方法区        堆               |
 *   |       -------------------------          |                         |                                            |
 *   -------------------------------------------                          |                                            |
 * java程序执行过程:加载 连接(验证 准备 解析) 初始化 使用 卸载                   ---------------------------------------------
 * 对加载过程的思考:
 * (1)通过全类名加载(forName("className"))类的二进制流文件到内存中
 * (2)将加载的二进制流文件的静态的数据结构转换为运行时数据结构
 * (3)在堆中创建一个java.lang.class对象 作为运行时数据访问的入口
 * 对连接的思考:
 * (1)验证
 *    首先验证二进制文件格式(保证输入的字节流能正确地解析并存储)
 *    其次验证元数据(对类的元数据信息进行语义校验)
 *    然后验证字节码(数据流和控制流的验证)
 *    最后验证符号引用
 * (2)准备
 *    为类变量和常量申请内存空间并赋系统默认值
 * (3)解析
 *   虚拟机将常量池内的符号引用替换为直接引用的过程(类和接口的解析 字段解析 类方法解析 接口方法解析 )
 * 对初始化的思考:
 * (1)<clinit>方法是由虚拟机自动收集类中静态变量的赋值语句和静态代码块中的语句合并而产生,虚拟机收集的顺序取决于代码在源文件中出现的顺序
 * (2)<clinit>方法和类的构造函数不同,它不需要显式的被调用,虚拟机会保证父类的<clinit>总是在子类的<clinit>方法调用前被调用.因此虚拟机中
 *    第一个执行<clinit>方法的类一定是java.lang.Object
 * (3)由于父类的<clinit>函数优先于子类的<clinit>执行,所以父类的静态变量赋值和静态代码块由于子类的静态变量赋值和静态代码块的执行
 * (4)<clinit>方法对于类和接口不是必须的,如果一个类或接口中没有静态变量赋值语句和静态代码块则编译器不会为其生成<clinit>方法
 * (5)接口的实现类初始化话时不会调用接口的<clinit>方法(笔者在探索中..)
 * (6)虚拟机会保证一个类的<clinit>方法在多线程执行环境中保证正确的加锁和同步

 * 对java jvm垃圾回收器的思考:
 * 判断jvm中是否对象存活的方法包括引用计数法和根搜索法
 * java jvm垃圾回收算法包括 标记删除法 复制法 标记整理法 分代法

 * 标记删除法:标记删除法分为标记阶段和删除阶段 标记阶段主要是标记jvm中可以回收的对象 删除阶段主要是释放标记阶段标记的对象 缺点:会造成大量内存碎片
 * 标记整理法:标记整理法首先将存活对象移动到内存中的一端 当需要垃圾回收时 直接释放端外边缘的内存
 * 复制法:将内存分为2块 一块用来保存对象 一块空闲 当需要垃圾回收时 首先将存活的对象复制到空闲块中 然后直接释放保存对象块的内存 缺点:内存利用率不高
 * 分代法:分代法根据对象存活的周期将内存分为新生代和老年代 新生代存放存活周期短的对象 老年代存放存活周期长的对象

 * java jvm垃圾回收机制和过程:
 * 当创建一个新对象时 jvm会首先检查新生代(Eden+Survivor(from space+to space))的Eden中是否有足够空间存放新对象 如果有则将新对象存放到Eden区
 * 否则触发垃圾回收(首先标记Eden和from space中存活的对象然后逐个复制到to space中,当to space中的内存不能存放某个对象时则将该对象直接存到老年代 然后是否Eden和from space的内存)

