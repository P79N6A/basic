本包演示单利模式并解析类加载的相关知识:
单利模式的特点:
(1)单例类的实例必须唯一
(2)单例类的实例必须由单例类自身初始化
(3)单例类的唯一实例必须可以供其他类访问
类加载的JVM透析:
            java源文件
                |
                |-------java编译器
                |
            class二进制文件
                |
                |-------类加载器
                |
       -----------------------------          ---------------------------------
       |   java.lang               |          |                                |
       |    .Class---->执行引擎     |          |                                |
       |     |            |        |          |   堆栈        本地方法栈         |
       |     ---------------       |          |                                |
       |    |               |      |          |  程序计数器     方法区     堆     |
       |    | 运行时数据区    |---------------> |                                |
       |    |               |      |          |                                |
       |    -----------------      |          |                                |
       -----------------------------          ---------------------------------
(1)编译
   通过编译器将.java的源文件编译成.class的二进制字节码文件
(2)装载
   类加载器通过全类名将二进制字节码文件加载到内存
   将静态的数据结构转换为运行时的数据结构
   在堆中生成java.lang.class对象作为运行时方法区数据的入口
(3)连接
   校验
      对二进制字节流文件格式的校验 验证当前版本的jvm是否能正确加载类文件
      对元数据的校验(校验元数据是否符合java语言规范)
      对字节码的校验(校验数据流和控制流是否合法)
      对符号引用的校验(字段域 类方法  接口方法 )
   准备
     将静态私有域和常量域赋予系统初始值
   解析
     将符号引用转为直接引用(类和接口的解析 类方法的解析 接口方法的解析 字段域的解析)
(4)初始化
   为类的静态域赋值(赋予用户设置的值) 调用类的静态块

   激活初始化方法的意图:
   显示new类的对象
   调用类的静态方法或者为类的静态域赋值
   通过反射调用类的构造方法
   入口函数main所在类的初始化
   初始化类时发现该类父类未初始化 则先去初始化父类
(5)实例化
   在堆中创建类的实例 实例化类的字段域(进行用户和系统的赋值操作)
(6)垃圾回收
   gc垃圾回收策略
(7)对象终结
   生命周期结束
(8)卸载
(校验和装载交替进行)

堆栈:指向常量池的引用 方法返回地址 局部变量列表 操作数栈 附加信息
程序计数器:存储cpu当前需要执行的计算机指令
堆:存放对象元素(实例化的域字段值)和数组元素
方法区:常量池中的常量引用 类名 类信息 方法信息 类变量引用
本地方法栈:

在jvm角度解析初始化:
(1)clinit方法是由虚拟机自动收集类的静态代码块和静态域赋值语句合并而成 其收集顺序由代码在类中的顺序决定
(2)clinit方法和构造方法不同 不需要显式调用 编译器会在类的clinit方法调用前优先调用父类的clinit方法
   java中的类均是Object类的子类 因此jvm首先调用的是Object类的clinit方法
(3)clinit方法不是必须的 如果一个类中没有静态代码块和静态域赋值语句 虚拟机不会创建clinit方法
(4)虚拟机保证clinit方法在多线程环境下可以正确的加锁和同步
(5)由于父类的clinit方法在子类的clinit方法执行前执行 因此父类的静态代码块和静态域赋值语句优秀于子类的静态代码块和静态域赋值执行
(6)接口的实现类不会调用接口的clinit方法(接口中不存在静态代码块和静态域赋值语句 虚拟机不会为其创建clinit方法)

gc垃圾回收算法:
(1)标记删除算法(将堆中可以被回收的对象标记 然后回收被标记的对象  缺点:产生大量内存碎片)
(2)复制算法(将内存划分为两个区域 将堆中不可以被回收的对象移动到另一块内存区域 然后直接释放原内存区域 缺点:浪费内存资源)
(3)标记整理算法(将堆中可以被回收的对象标记 将不可回收的对象移动到内存区域的一端 然后清除端边界外的内存)
(4)分代算法(将内存分为新生代(Eden+Survivor(from space+to space))和老年代 新生代存放存活周期短的对象 老年代存放存活周期长的对象)

jvm实例化对象全过程:
    当jvm需要新建一个对象时 首先会检查新生代(Eden+Survivor(from space+to space))的内存是否可以存放该对象 如果可以存放则不触发gc 如果存放不下则触发gc.
gc过程:
     首先标记新生代的eden区中不可以被回收的对象 如果survivor to space区的内存足够 则将被标记的对象和survivor from space区的对象移动到survivor to space区 然后回收新生代部分内存(survivor to space 和 eden)
     否则对survivor to space区域进行gc(如果老年代内存足够 将survivor to space区中的对象移动到老年代 否则抛出内存溢出溢出)

对类加载器的思考:
启动类加载器(bootstrap):负责加载核心类库包(java_home/jre/lib/rt.jar),启动类加载器由c++编写因此没有java类与之对应
扩展类加载器(extclassloader):负责加载扩展包(java_home/jre/lib/ext/*.jar),由java实现对应extclassloader类
系统类加载器(appclassloader):负责加载classpath路径下的包
自定义类加载器:继承classloaer并实现findClass方法







