/**
 * Created by qfl on 16/4/20.
 * String StringBulider StringBuffer解析:
 * String:
 * String为final类即不可被子类继承
 * 实现接口CharSequence Compareable Serivaliable
 * 内部用常量数组实现即一旦赋值就不能修改
 * 内部方法操作都是把当前字符数组复制后进行操作并且返回新的字符串对象
 * 线程不安全 覆写Object的equals和hashCode方法
 * StringBuilder:
 * StringBuilder为final类即不可被子类继承
 * 内部由字符数组实现可以动态添加字符
 * 继承自抽象类AbstractStringBuilder 实现接口CharSequence Appendable Servializable可变字符串
 * 线程不安全 没有覆盖Object的hashCode和equals方法 没有实现Compareable接口
 * StringBuffer:
 * StringBuffer为final类即不可被子类继承
 * 内部由字符数组实现可以动态添加字符
 * 内部方法大多为同步方法
 * 继承自抽象类AbstractStringBuilder 实现接口CharSequence Appendable Servializable可变字符串
 * 线程安全 没有覆盖Object的hashCode和equals方法 没有实现Compareable接口
 * 关于java中控制访问权限的思考:
 * 外部类的访问权限只能是public和包访问权限 类文件只能包含一个public类并且类文件名必须与public类名相同 内部类可以被任意控制访问权限修饰符修饰
 * 当外部类被public修饰时则可以在任何包中的类对该类进行实例化
 * 当外部类的访问控制权为默认时只能在该类所在包的其他类对该类进行实例化
 * 当非静态内部类被public修饰时则可以在任何包中通过外部类实例对该内部类实例化
 * 当静态内部类被public修饰时则可以在任何包中通过外部类类名对该内部类实例化
 * 当非静态内部类的控制权限为包控制权限时则可以在该类所在外部类包中的其他类中通过外部类实例对该内部类实例化
 * 当静态内部类的控制访问权限为包控制访问权限时则可以在该类所在外部类包中的其他类中通过类名对该内部类实例化
 * 当非静态内部类被protected修饰时则可以在该类所在外部类包中的其他类中通过外部类实例对该类进行实例化 但在其他包中此内部类所在外部类的子类可以访问但不能进行实例化(原因笔者在探讨)
 * 当静态内部类被protected修饰时则可以在该类所在外部类包中的其他类中通过外部类类名对该类进行实例化 但在其他包中此内部类所在外部类的子类可以访问但不能进行实例化(原因笔者亦在探讨)
 * 当非静态内部类的控制访问权限为私有访问权限时则只可以在该类的外部类内部通过外部类实例对该内部类实例化
 * 当静态内部类的访问权限为私有访问权限时则只可以在该类的外部类内部通过外部类类名对该内部类实例化
 * Java常见关键字的枚举:
 * 关于==和equals的思考:
 * ==作用于基本数据类型时比较的是基本数据类型的值 ==作用于引用类型时比较的是对象在内存(堆)中存储的地址
 * equals不能作用于基本数据类型 如果没有对equals方法进行覆写则equals比较的是对象在内存(堆)中存储的地址 否则将根据覆写后的逻辑进行比较(一般比较对象存储的值)
 * 关于hashCode的思考:
 * 相同对象的hashCode值相同 hashCode相同不能保证对象相同
 * 对于未覆盖hashCode方法的对象 hashCode方法返回对象的内存地址
 * 对于覆盖hashCode方法的对象 hashCode方法返回根据一定规则对内存地址计算后的常数
 * 对于键值对映射集合 hashCode用来产生散列码
 */